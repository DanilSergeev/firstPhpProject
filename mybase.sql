-- phpMyAdmin SQL Dump
-- version 5.0.2
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1:3306
-- Время создания: Янв 11 2023 г., 13:12
-- Версия сервера: 10.3.22-MariaDB
-- Версия PHP: 7.4.5

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `mybase`
--

-- --------------------------------------------------------

--
-- Структура таблицы `articles`
--

CREATE TABLE `articles` (
  `id` int(11) UNSIGNED NOT NULL,
  `title` varchar(100) NOT NULL,
  `image` varchar(255) DEFAULT NULL,
  `text` text NOT NULL,
  `categorie_1` int(11) DEFAULT NULL,
  `pubdate` int(11) NOT NULL,
  `views` int(11) NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `articles`
--

INSERT INTO `articles` (`id`, `title`, `image`, `text`, `categorie_1`, `pubdate`, `views`) VALUES
(1, 'Поколения ЭВМ', '1', 'Всю историю развития электронно-вычислительной техники принято делить на поколения. Смены поколений чаще всего были связаны со сменой элементной базы ЭВМ, с прогрессом электронной техники. Это всегда приводило к росту быстродействия и увеличению объема памяти. Кроме этого, как правило, происходили изменения в архитектуре ЭВМ, расширялся круг задач, решаемых на ЭВМ, менялся способ взаимодействия между пользователем и компьютером. </br>\r\n\r\nЭВМ первого поколения были ламповыми машинами 50-х годов. Их элементной базой были электровакуумные лампы. Эти ЭВМ были весьма громоздкими сооружениями, содержавшими в себе тысячи ламп, занимавшими иногда сотни квадратных метров территории, потреблявшими электроэнергию в сотни киловатт.</br>\r\n\r\nНапример, одна из первых ЭВМ –ENIAC –представляла собой огромный по объему агрегат длиной более 30 метров, содержала 18 тысяч электровакуумных ламп и потребляла около 150 киловатт электроэнергии.</br>\r\n\r\nДля ввода программ и данных применялись перфоленты и перфокарты. Не было монитора, клавиатуры и мышки. Использовались эти машины, главным образом, для инженерных и научных расчетов, не связанных с переработкой больших объемов данных. В 1949 году в США был создан первый полупроводниковый прибор, заменяющий электронную лампу. Он получил названиетранзистор.</br>\r\n\r\nВ 60-х годах транзисторы стали элементной базой для ЭВМ второго поколения. Машины стали компактнее, надежнее, менее энергоемкими. Возросло быстродействие и объем внутренней памяти. Большое развитие получили устройства внешней (магнитной) памяти: магнитные барабаны, накопители на магнитных лентах. В этот период стали развиваться языки программирования высокого уровня: ФОРТРАН, АЛГОЛ, КОБОЛ. Составление программы перестало зависеть от конкретной модели машины, сделалось проще, понятнее, доступнее.</br>\r\n\r\nВ 1959 г. был изобретен метод, позволивший создавать на одной пластине и транзисторы, и все необходимые соединения между ними. Полученные таким образом схемы стали называться интегральными схемами или чипами. Изобретение интегральных схем послужило основой для дальнейшей миниатюризации компьютеров.</br>\r\n\r\nВ дальнейшем количество транзисторов, которое удавалось разместить на единицу площади интегральной схемы, увеличивалось приблизительно вдвое каждый год.</br>\r\n\r\nТретье поколение ЭВМсоздавалось на новой элементной базе –интегральных схемах (ИС).</br>\r\n\r\nЭВМ третьего поколения начали производиться во второй половине 60-х годов, когда американская фирма IBM приступила к выпуску системы машин IBM-360. Немного позднее появились машины серии IBM-370.</br>\r\n\r\nВ Советском Союзе в 70-х годах начался выпуск машин серии ЕС ЭВМ (Единая система ЭВМ) по образцу IBM 360/370. Скорость работы наиболее мощных моделей ЭВМ достигла уже нескольких миллионов операций в секунду. На машинах третьего поколения появился новый тип внешних запоминающих устройств – магнитные диски.</br>\r\n\r\nУспехи в развитии электроники привели к созданиюбольших интегральных схем (БИС), где в одном кристалле размещалось несколько десятков тысяч электрических элементов.</br>\r\n\r\nВ 1971 году американская фирма Intel объявила о создании микропроцессора. Это событие стало революционным в электронике. Микропроцессор– это миниатюрный мозг, работающий по программе, заложенной в его память. Соединив микропроцессор с устройствами ввода-вывода и внешней памяти, получили новый тип компьютера: микро-ЭВМ. Микро-ЭВМ относится к ЭВМ четвертого поколения. Наибольшее распространение получили персональные компьютеры (ПК). Их появление связано с именами двух американских специалистов: Стива Джобса и Стива Возняка. В 1976 году на свет появился их первый серийный ПК Apple-1, а в 1977 году – Apple-2. Однако с 1980 года «законодателем мод» на рынке ПК становится американская фирма IBM. Ее архитектура стала фактически международным стандартом на профессиональные ПК. Машины этой серии получили название IBM PC (Personal Computer). Появление и распространение ПК по своему значению для общественного развития сопоставимо с появлением книгопечатания. С развитием этого типа машин появилось понятие «информационные технологии», без которых невозможно обойтись в большинстве областей деятельности человека. Появилась новая дисциплина – информатика. ЭВМ пятого поколения будут основаны на принципиально новой элементной базе. Основным их качеством должен быть высокий интеллектуальный уровень, в частности, распознавание речи, образов. Это требует перехода оттрадиционной фон-неймановской архитектуры компьютера кархитектурам, учитывающим требования задач создания искусственного интеллекта. Таким образом, для компьютерной грамотности необходимо понимать, что на данный моментсоздано четыре поколения ЭВМ:</br></br>\r\n\r\n1-ое поколение: 1946 г. создание машины ЭНИАК на электронных лампах.</br>\r\n2-ое поколение: 60-е годы. ЭВМ построены на транзисторах.</br>\r\n3- е поколение: 70-е годы. ЭВМ построены на интегральных микросхемах (ИС).</br>\r\n4-ое поколение: Начало создаваться с 1971 г. с изобретением микропроцессора (МП). Построены на основе больших интегральных схем (БИС) и сверх БИС (СБИС).</br>\r\nПятое поколение ЭВМ строится по принципу человеческого мозга, управляется голосом. Соответственно, предполагается применение принципиально новых технологий. Огромные усилия были предприняты Японией в разработке компьютера 5-го поколения с искусственным интеллектом, но успеха они пока не добились. Фирма IBM тоже не намерена сдавать свои позиции мирового лидера, например, Японии. Мировая гонка за создание компьютера пятого поколения началась еще в 1981 году. С тех пор еще никто не достиг финиша.</br> Поживем – увидим.\r\n\r\n', 3, 1599457594, 4),
(2, 'Операционная Система', '2', '<strong>Функции и классификация операционных систем</strong> </br>\r\nОперационная система — комплекс взаимосвязанных программ, который\r\nдействует как интерфейс между приложениями и пользователями с одной\r\nстороны, и аппаратурой компьютера с другой стороны [1].</br>\r\nОС выполняет две группы функций:\r\n- предоставление пользователю или программисту вместо реальной\r\nаппаратуры компьютера расширенной виртуальной машины, с которой\r\nудобнее работать и которую легче программировать;</br>\r\n- повышение эффективности использования компьютера путем\r\nрационального управления его ресурсами в соответствии с некоторым\r\nкритерием.</br>\r\nБолее детально эти группы функций можно представить следующим\r\nобразом. По современным представлениям ОС должна:</br>\r\n− Обеспечивать загрузку пользовательских программ в оперативную\r\nпамять и их исполнение.</br>\r\n− Обеспечивать управление памятью.</br>\r\n− Обеспечивать работу с устройствами долговременной памяти, такими как\r\nвинчестеры, магнитные ленты, компакт-диски, флэш-память и т.п. Как\r\nправило, ОС структурирует данные на этих носителях в виде файловых\r\nсистем.</br>\r\n− Предоставлять стандартизированный доступ к различным периферийным\r\nустройствам, таким как модемы, принтеры, сканеры и т.д.</br>\r\n− Предоставлять некоторый пользовательский интерфейс.</br>\r\n− Обеспечивать параллельное или псевдопараллельное исполнение\r\nнескольких задач.</br>\r\n− Обеспечивать организацию взаимодействия задач друг с другом.</br>\r\n− Обеспечивать организацию межмашинного взаимодействия и\r\nразделение ресурсов.</br>\r\n− Обеспечивать защиту системных ресурсов, данных и программ\r\nпользователя, исполняющихся процессов и самой себя от ошибочных и\r\nзловредных действий пользователей и программ.</br>\r\n− Обеспечивать аутентификацию, авторизацию и другие средства\r\nобеспечения безопасности.</br>\r\nПо тому, какие из вышеперечисленных функций реализованы и каким было\r\nуделено больше внимания, системы можно разделить на несколько классов:</br>\r\n− ОС общего назначения;</br>\r\n− системы виртуальных машин;</br>\r\n− операционные системы реального времени.</br></br>\r\nОС общего назначения берут на себя выполнение всех\r\nвышеперечисленных функций. Это системы, рассчитанные на интерактивную\r\nработу одного или нескольких пользователей в режиме разделения времени, при\r\nне очень жестких требованиях ко времени реакции системы на внешние события.\r\nОбычно подобные системы используют встроенные в архитектуру процессора\r\nсредства защиты и виртуализации памяти. К этому классу относятся, например,\r\nWindows 2000, системы семейства Unix. </br>\r\n \r\nПоявились ОС общего назначения в результате эволюции дисковых ОС\r\n(ДОС), которые, как правило, берут на себя выполнение только первых пяти\r\nфункций. ДОС загружает пользовательскую программу в память и передает ей\r\nуправление, после чего программа делает с системой все, что ей необходимо.\r\nПри некорректной работе программы дальнейшая работа может стать\r\nневозможной, т.к. ОС не контролирует ее действия.</br>\r\nСистема виртуальных машин (СВМ) — ОС, допускающая одновременную\r\nработу нескольких программ, но создающая каждой из них иллюзию того, что\r\nмашина находится в полном ее распоряжении. Зачастую «программой»\r\nоказывается полноценная ОС, что позволяет выполнять приложения,\r\nнаписанные для одной ОС, под «управлением» другой. Часто СВМ является\r\nподсистемой ОС общего назначения: сессия DOS в Windows 9x, эмуляторы DOS\r\nи Windows для Unix и OS/2.</br>\r\nОС реального времени (ОСРВ) — ОС, гарантирующая, что максимальное\r\nвремя реакции на внешнее событие (латентное время) и время переключения\r\nмежду задачами не превышают некоторых, наперед заданных, величин.\r\nСпособность гарантировать выполнение этих условий и просто высокая\r\nпроизводительность — разные вещи. Алгоритмы, обеспечивающие хорошее\r\nсреднее время реакции, далеко не всегда способны гарантировать, что\r\nлатентное время не превысит определенной величины. В процессе эксплуатации\r\nпоявилась необходимость гарантировать не только верхний, но и нижний предел\r\nвремени реакции на внешнее событие, что требуется для обеспечения\r\nнормальной работы сложных механических систем. Примером ОСРВ является\r\nQNX.     </br></br>       <strong>АРХИТЕКТУРА ОПЕРАЦИОННЫХ СИСТЕМ</strong></br>\r\nНаиболее общим подходом к структуризации ОС является разделение всех\r\nее модулей на две группы [1]:</br>\r\n- ядро — модули, выполняющие основные функции ОС;</br>\r\n- модули, выполняющие вспомогательные функции ОС.</br>\r\nМодули ядра выполняют такие базовые функции ОС, как управление\r\nпроцессами, памятью, устройствами ввода/вывода и т.п. Ядро составляет\r\nсердцевину ОС, без него ОС является полностью неработоспособной.\r\nВ состав ядра входят функции, решающие внутрисистемные задачи\r\nорганизации вычислительного процесса, такие как переключение контекстов,\r\nзагрузка/выгрузка страниц, обработка прерываний. Эти функции недоступны для\r\nприложений. Другой класс функций ядра служит для поддержки приложений,\r\nсоздавая для них прикладную программную среду. Приложения могут\r\nобращаться к ядру с запросами — системными вызовами — для выполнения тех\r\nили иных действий, например, для открытия файла, вывода информации на\r\nдисплей и т.д. Функции ядра, которые могут вызываться приложениями,\r\nобразуют интерфейс прикладного программирования — Application Programming\r\nInterface (API).</br>\r\nОстальные модули ОС выполняют менее обязательные функции,\r\nнапример, дефрагментацию диска. Обычно они подразделяются на следующие\r\nгруппы: </br>\r\n \r\n- утилиты — программы, решающие отдельные задачи управления и\r\nсопровождения компьютерной системы, такие, например, как программы\r\nсжатия дисков, архивирования и т.п.;</br>\r\n- системные обрабатывающие программы — текстовые или графические\r\nредакторы, компиляторы, компоновщики, отладчики;</br>\r\n- программы предоставления пользователю дополнительных услуг —\r\nспециальный вариант пользовательского интерфейса, калькулятор и\r\nдаже игры;</br>\r\n- библиотеки процедур различного назначения, упрощающие разработку\r\nприложений, например, библиотека математических функций, функций\r\nввода/вывода и т.п.</br>\r\nДля надежного управления ходом выполнения приложений ОС должна\r\nиметь по отношению к ним определенные привилегии. Иначе некорректно\r\nработающее приложение может вмешаться в работу ОС и, например, разрушить\r\nчасть ее кодов. Также ОС должна обладать исключительными полномочиями,\r\nдля того, чтобы играть роль арбитра в споре приложений за системные ресурсы\r\nв мультипрограммном режиме.</br>\r\nОбеспечить привилегии ОС невозможно без специальных средств\r\nаппаратной поддержки. Аппаратура компьютера должна поддерживать как\r\nминимум два режима работы — пользовательский и привилегированный (режим\r\nядра или супервизора). Так как ядро выполняет основные функции ОС, то чаще\r\nвсего именно оно работает в привилегированном режиме. Иногда работа в\r\nпривилегированном режиме служит основным определением понятия «ядро».\r\nВычислительную систему (ВС), работающую под управлением ОС на\r\nоснове ядра, можно рассматривать как систему, состоящую из трех иерархически\r\nрасположенных слоев: нижний слой образует аппаратура, промежуточный —\r\nядро, а утилиты, обрабатывающие программы и приложения, составляют\r\nверхний слой системы. Слоистую структуру ВС принято изображать в виде\r\nсистемы концентрических окружностей (рис. 2.1), иллюстрируя тот факт, что\r\nкаждый слой может взаимодействовать только со смежными слоями.</br>\r\n\r\nМногослойный подход является универсальным и эффективным способом\r\nдекомпозиции сложных систем любого типа, в том числе и программных. В\r\nсоответствии с этим подходом система состоит из иерархии слоев, каждый из\r\nкоторых обслуживает вышележащий слой, выполняя для него некоторый набор\r\nфункций, которые образуют межслойный интерфейс.</br>\r\nПоскольку ядро представляет собой сложный многофункциональный\r\nкомплекс, то многослойный подход обычно распространяется и на структуру\r\nядра. Оно может состоять из слоев:</br>\r\n− Средства аппаратной поддержки ОС — средства поддержки\r\nпривилегированного режима, систему прерываний, средства\r\nпереключения контекстов процессоров, средства защиты областей\r\nпамяти и т.п.</br>\r\n− Машинно-зависимые компоненты ОС — программные модули, в\r\nкоторых отражается специфика аппаратной платформы компьютера. В\r\nидеале этот слой полностью экранирует вышележащие слои от\r\nособенностей аппаратуры, что позволяет разрабатывать вышележащие\r\nслои на основе машинно-независимых модулей, существующих в\r\nединственном экземпляре для всех типов аппаратных платформ,\r\nподдерживаемых данной ОС.</br>\r\n− Базовые механизмы ядра — программное переключение контекстов\r\nпроцессоров, диспетчеризацию прерываний, перемещение страниц\r\nпамяти на диск и обратно и т.п. Модули этого слоя не принимают\r\nрешений о распределении ресурсов — они только отрабатывают\r\nпринятые «наверху» решения, что и дает повод называть их\r\nисполнительными механизмами для модулей верхних слоев.\r\n− Менеджеры ресурсов — модули, реализующие стратегические задачи\r\nпо управлению основными ресурсами вычислительной системы. Обычно\r\nна данном слое работают менеджеры (диспетчеры) процессов, вводавывода, файловой системы и оперативной памяти.\r\n− Интерфейс системных вызовов — самый верхний слой ядра,\r\nвзаимодействующий непосредственно с приложениями и системными\r\nутилитами.</br>\r\nПриведенное разбиение ядра является достаточно условным. Для\r\nускорения работы в некоторых случаях происходит непосредственное\r\nобращение с верхнего слоя к функциям нижних слоев, минуя промежуточные.\r\nВыбор количества слоев ядра является ответственным и сложным делом:\r\nувеличение числа слоев ведет к некоторому замедлению работы ядра за счет\r\nдополнительных накладных расходов на межслойное взаимодействие, а их\r\nуменьшение ухудшает расширяемость и логичность системы.</br>\r\nМикроядерная архитектура является альтернативой классическому способу\r\nпостроения ОС. Ее суть состоит в следующем. В привилегированном режиме\r\nвыполняется небольшая часть ОС, называемая микроядром, в состав которого\r\nвходят базовые функции по управлению процессами, обработке прерываний,\r\nуправлению виртуальной памятью, пересылке сообщений и управлению\r\nустройствами ввода/вывода, связанные с загрузкой или чтением регистров\r\nустройств. Набор функций микроядра обычно соответствует функциям слоя\r\nбазовых механизмов обычного ядра. Все остальные функции ядра оформляются\r\n </br>\r\nв виде приложений, работающих в пользовательском режиме, при этом многие\r\nменеджеры ресурсов, являющиеся неотъемлемыми частями обычного ядра —\r\nфайловая система, подсистемы управления виртуальной памятью и процессами,\r\nменеджер безопасности и т.п., — становятся модулями, работающими в\r\nпользовательском режиме.</br>\r\nРабота таких менеджеров имеет принципиальные отличия от утилит и\r\nобрабатывающих программ ОС, которые также оформляются в виде\r\nпользовательских приложений. Утилиты и обрабатывающие программы\r\nвызываются, в основном, пользователями, и их функции редко требуются другим\r\nприложениям. Основным назначением многих менеджеров является именно\r\nобслуживание запросов других приложений, например, создание процесса,\r\nпроверка прав доступа к ресурсу и т.д. Именно поэтому менеджеры ресурсов,\r\nвынесенные в пользовательский режим, называются серверами ОС. Из этого\r\nвытекает необходимость наличия в ОС удобного и эффективного механизма\r\nвызова процедур одного процесса из другого, а его поддержка является одной из\r\nглавных задач микроядра.</br>\r\nСхематично этот механизм выглядит следующим образом. Клиент, которым\r\nможет быть любая прикладная программа или другой компонент ОС,\r\nзапрашивает выполнение некоторой функции у соответствующего сервера,\r\nпосылая ему сообщение. Непосредственная передача сообщений между\r\nприложениями невозможна, т.к. их адресные пространства изолированы друг от\r\nдруга. Микроядро, имеющее доступ к адресным пространствам всех приложений,\r\nвыступает посредником при передаче сообщения. Сначала оно передает имя и\r\nпараметры вызываемой процедуры серверу, затем сервер выполняет\r\nзапрошенную операцию, после чего ядро возвращает результаты клиенту с\r\nпомощью другого сообщения.</br>\r\nОС, основанные на концепции микроядра, в высокой степени\r\nудовлетворяют большинству требований, предъявляемых к современным ОС,\r\nобладая переносимостью, расширяемостью, надежностью и создавая хорошие\r\nпредпосылки для поддержки распределенных приложений. За это приходится\r\nплатить снижением производительности, которое является основным\r\nнедостатком микроядерной архитектуры.</br></br>                                                                                         ', 3, 1599550376, 100),
(3, 'Алгоритм', '3', '1.1. Понятие алгоритма\r\nи его свойства</br>\r\nАлгоритмом называют точное предписание, которое задается\r\nвычислительному процессу и представляет собой конечную после‑\r\nдовательность обычных элементарных действий, четко опреде‑\r\nляющую процесс преобразования исходных данных в искомый\r\nрезультат. Приведенная фраза представляет собой не определение,\r\nа объяснение сути, поскольку понятие алгоритма является фунда‑\r\nментальным и не может быть выражено через другие, поэтому его\r\nследует рассматривать как неопределяемое.</br>\r\nВ качестве примера алгоритма приведем алгоритм Евклида\r\nдля нахождения наибольшего общего делителя (НОД) двух нату‑\r\nральных чисел. Вот одна из возможных формулировок этого алго‑\r\nритма, описанная по шагам:</br>\r\n1) присвоить переменным X и Y значения, НОД которых ищется;</br>\r\n2) если X > Y, то перейти на шаг 5;</br>\r\n3) если X < Y, то перейти на шаг 6;</br>\r\n4) здесь X = Y. Выдать Х в качестве результата. Конец работы;</br>\r\n5) заменить пару (Х, Y) парой (Х – Y, Y) и вернуться на шаг 2;</br>\r\n6) заменить пару (Х, Y) парой (Х, Y – Х) и вернуться на шаг 2.</br>\r\nВыяснение того, какие объекты и действия над ними следует счи‑\r\nтать точно определенными, какими возможностями обладают ком‑\r\nбинации элементарных действий, что можно и чего нельзя сделать\r\nс их помощью, — все это предмет теории алгоритмов и формальных\r\nсистем, которая первоначально возникла в рамках математики и стала\r\nважнейшей ее частью. Как указывал В. А. Успенский, самым главным\r\nоткрытием в науке об алгоритмах, безусловно, было открытие самого\r\nпонятия алгоритма в качестве новой и отдельной сущности.\r\nВычисления протекают во времени и в пространстве. Каждый\r\nшаг алгоритма выполняется за какое‑то конечное время. Для раз‑\r\nмещения данных необходимо пространство — память. Рассмот‑\r\nрим основные свойства алгоритма.</br>\r\nКаждый алгоритм имеет дело с дан‑\r\nными — входными, промежуточными\r\nи выходными.</br></br>\r\nСвойства алгоритма:</br>\r\n\r\nКонечность. Понимается двояко: во‑первых, алгоритм состоит\r\nиз отдельных элементарных шагов, или действий, причем множе‑\r\nство различных шагов, из которых составлен алгоритм, конечно.\r\nВо‑вторых, алгоритм должен заканчиваться за конечное число\r\nшагов. Если строится бесконечный, сходящийся к искомому реше‑\r\nнию процесс, то он обрывается на некотором шаге и полученное\r\nзначение принимается за приближенное решение рассматривае‑\r\nмой задачи. Точность приближения зависит от числа шагов.</br>\r\nЭлементарность (понятность). Каждый шаг алгоритма дол‑\r\nжен быть простым, чтобы устройство, выполняющее операции,\r\nмогло выполнить его одним действием.</br>\r\nДискретность. Процесс решения задачи представляется конеч‑\r\nной последовательностью отдельных шагов, и каждый шаг алгоритма\r\nвыполняется за конечное (не обязательно единичное) время.</br>\r\nДетерминированность (определенность). Каждый шаг алго‑\r\nритма должен быть однозначно и недвусмысленно определен и не дол‑\r\nжен допускать произвольной трактовки. После каждого шага либо\r\nуказывается, какой шаг делать дальше, либо дается команда оста‑\r\nновки, после чего работа алгоритма считается законченной.</br>\r\nРезультативность. Алгоритм имеет некоторое число вход‑\r\nных величин — аргументов. Цель выполнения алгоритма состоит\r\nв получении конкретного результата, имеющего вполне опреде‑\r\nленное отношение к исходным данным. Алгоритм должен оста‑\r\nнавливаться после конечного числа шагов, зависящего от дан‑\r\nных, с указанием того, что считать результатом. Если решение\r\nне может быть найдено, то должно быть указано, что в этом слу‑\r\nчае считать результатом.</br>\r\nМассовость. Алгоритм решения задачи разрабатывается\r\nв общем виде, т.е. он должен быть применим для некоторого класса\r\nзадач, различающихся лишь исходными данными. При этом исход‑\r\nные данные могут выбираться из некоторой области, которая назы‑\r\nвается областью применимости алгоритма.</br>\r\nЭффективность. Одну и ту же задачу можно решить по‑раз‑\r\nному и соответственно за разное время и с различными затратами\r\nпамяти. Желательно, чтобы алгоритм состоял из минимального\r\nчисла шагов и при этом решение удовлетворяло бы условию точ‑\r\nности и требовало минимальных затрат других ресурсов.\r\nТочное математическое определение алгоритма затрудняется\r\nтем, что интерпретация предусмотренных предписаний не должна \r\nзависеть от выполняющего их субъекта. В зависимости от своего\r\nинтеллектуального уровня он может либо не понять, что имеется\r\nв виду в инструкции, либо интерпретировать ее непредусмотрен‑\r\nным образом.</br>\r\nМожно обойти проблему интерпретации правил, если наряду\r\nс формулировками предписаний описать конструкцию и принцип\r\nдействия интерпретирующего устройства. Это позволяет избе‑\r\nжать неопределенности и неоднозначности в понимании одних\r\nи тех же инструкций. Для этого необходимо задать язык, на кото‑\r\nром описывается множество правил поведения, либо последова‑\r\nтельность действий, а также само устройство, которое может интер‑\r\nпретировать предложения, сделанные на этом языке, и выполнять\r\nшаг за шагом каждый точно определенный процесс. Оказывается,\r\nчто такое устройство (машину) можно выполнить в виде, кото‑\r\nрый остается постоянным независимо от сложности рассматри‑\r\nваемой процедуры.</br>\r\nВ настоящее время можно выделить три основных типа универ‑\r\nсальных алгоритмических моделей. Они различаются исходными\r\nпосылками относительно определения понятия алгоритма.\r\nПервый тип связывает понятие алгоритма с наиболее традици‑\r\nонными понятиями математики — вычислениями и числовыми\r\nфункциями. Второй тип основан на представлении об алгоритме\r\nкак о некотором детерминированном устройстве, способном выпол‑\r\nнять в каждый отдельный момент лишь весьма примитивные опера‑\r\nции. Такое представление обеспечивает однозначность алгоритма\r\nи элементарность его шагов. Кроме того, такое представление соот‑\r\nветствует идеологии построения компьютеров. Основной теоре‑\r\nтической моделью этого типа, созданной в 1930‑х гг. английским\r\nматематиком Аланом Тьюрингом, является машина Тьюринга.\r\nТретий тип — это преобразования слов в произвольных алфа‑\r\nвитах, в которых элементарными операциями являются подста‑\r\nновки, т.е. замены части слова (под словом понимается последо‑\r\nвательность символов алфавита) другим словом. Преимущества\r\nэтого типа моделей состоят в его максимальной абстрактности\r\nи возможности применить понятие алгоритма к объектам произ‑\r\nвольной (необязательно числовой) природы. Примеры моделей\r\nтретьего типа — канонические системы американского матема‑\r\nтика Эмиля Л. Поста и нормальные алгоритмы, введенные совет‑\r\nским математиком А. А. Марковым.</br>\r\n\r\nМодели второго и третьего типа довольно близки и отлича‑\r\nются в основном эвристическими акцентами, поэтому не случайно\r\nговорят о машине Поста, хотя сам Пост такое название не вводил.\r\nЗапись алгоритма на некотором языке представляет собой про‑\r\nграмму. Если программа написана на специальном алгоритмиче‑\r\nском языке (например, на ПАСКАЛе или БЕЙСИКе), то говорят\r\nоб исходной программе. Программа, написанная на языке, кото‑\r\nрый непосредственно понимает компьютер (как правило, это дво‑\r\nичные коды), называется машинной, или двоичной.\r\nЛюбой способ записи алгоритма подразумевает, что всякий\r\nописываемый с его помощью предмет задается как конкретный\r\nпредставитель некоторого класса объектов, которые можно опи‑\r\nсывать данным способом.</br>\r\nСредства, используемые для записи алгоритмов, в значитель‑\r\nной мере определяются тем, кто будет исполнителем.\r\nЕсли исполнителем будет человек, запись может быть не пол‑\r\nностью формализована, на первое место выдвигаются понятность\r\nи наглядность. В этом случае можно использовать словесную форму\r\nзаписи или схемы алгоритмов.</br>\r\nДля записи алгоритмов, предназначенных для исполнителей‑ав‑\r\nтоматов, необходима формализация, поэтому в таких случаях при‑\r\nменяют формальные специальные языки. Преимущество формаль‑\r\nного способа записи состоит в том, что он дает возможность изучать\r\nалгоритмы как математические объекты; при этом формальное\r\nописание алгоритма служит основой, позволяющей интеллекту‑\r\nально охватить этот алгоритм.</br>\r\nДля записи алгоритмов используют самые разнообразные сред‑\r\nства. Выбор средства определяется типом исполняемого алгоритма.\r\nВыделяют следующие основные способы записи алгоритмов:</br>\r\n вербальный — алгоритм описывается на человеческом\r\nязыке;</br>\r\n символьный — алгоритм описывается с помощью набора\r\nсимволов;</br>\r\n графический — алгоритм описывается с помощью набора гра‑\r\nфических изображений.</br>\r\nОбщепринятыми способами записи алгоритма являются графи‑\r\nческая запись с помощью схем алгоритмов (блок‑схем) и символь‑\r\nная запись с помощью какого‑либо алгоритмического языка.</br>\r\n\r\nДля описания алгоритма с помощью схем изображают связан‑\r\nную последовательность геометрических фигур, каждая из кото‑\r\nрых подразумевает выполнение определенного действия алгоритма.\r\nПорядок выполнения действий указывается стрелками.</br>\r\n\r\nИмеются примитивы для операций ввода и вывода данных,\r\nа также другие графические символы. В настоящий момент они\r\nопределены стандартом ГОСТ 19.701—90 (ИСО 5807—85) «Еди‑\r\nная система программной документации. Схемы алгоритмов, про‑\r\nграмм, данных и систем. Условные обозначения и правила выпол‑\r\nнения». Всего сборник ЕСПД содержит 28 документов.\r\nПо схеме алгоритма легко составить исходную программу\r\nна алгоритмическом языке.</br>\r\nВ зависимости от последовательности выполнения действий\r\nв алгоритме выделяют алгоритмы линейной, разветвленной и цик‑\r\nлической структуры.</br>\r\nВ алгоритмах линейной структуры действия выполняются пос‑\r\nледовательно одно за другим.</br>\r\nВ алгоритмах разветвленной структуры в зависимости от\r\nвыполнения или невыполнения какого‑либо условия производятся\r\nразличные последовательности действий. Каждая такая последо‑\r\nвательность действий называется ветвью алгоритма.</br>\r\nВ алгоритмах циклической структуры в зависимости от выпол‑\r\nнения или невыполнения какого‑либо условия выполняется повто‑\r\nряющаяся последовательность действий, называющаяся телом\r\nцикла. Вложенным называется цикл, находящийся внутри тела\r\nдругого цикла. Итерационным называется цикл, число повторе‑\r\nний которого не задается, а определяется в ходе выполнения цикла.</br>\r\nОдно повторение цикла называется итерацией.', 3, 1599636844, 12),
(4, 'Сетевые адаптеры', '4', '<strong>Сетевой адаптер</strong> (Network Interface Card, NIC) – это периферийное устройство компьютера, непосредственно взаимодействующее со средой передачи данных, которая прямо или через другое коммуникационное оборудование связывает его с другими компьютерами. Это устройство решает задачи надежного обмена двоичными данными, представленными соответствующими электромагнитными сигналами, по внешним линиям связи. Как и любой контроллер компьютера, сетевой адаптер работает под управлением драйвера операционной системы, и распределение функций между сетевым адаптером и драйвером может изменяться от реализации к реализации.\r\n<br>\r\nВ первых локальных сетях сетевой адаптер с сегментом коаксиального кабеля представлял собой весь спектр коммуникационного оборудования, с помощью которого организовывалось взаимодействие компьютеров. Сетевой адаптер компьютера-отправителя непосредственно по кабелю взаимодействовал с сетевым адаптером компьютера-получателя. В большинстве современных стандартов для локальных сетей предполагается, что между сетевыми адаптерами взаимодействующих компьютеров устанавливается специальное коммуникационное устройство (концентратор, мост, коммутатор или маршрутизатор), которое берет на себя некоторые функции по управлению потоком данных.\r\n<br>\r\nСетевые адаптеры различаются по типу и разрядности используемой в компьютере внутренней шины данных – ISA, EISA, PCI, MCA.\r\n<br><br>\r\nСетевые адаптеры различаются также по типу принятой в сети сетевой технологии – Ethernet, Token Ring, FDDI и т.п. Как правило, конкретная модель сетевого адаптера работает по определенной сетевой технологии (например, Ethernet). В связи с тем, что для каждой технологии сейчас имеется возможность использования различных сред передачи данных (тот же Ethernet поддерживает коаксиальный кабель, неэкранированную витую пару и оптоволоконный кабель), сетевой адаптер может поддерживать как одну, так и одновременно несколько сред. В случае, когда сетевой адаптер поддерживает только одну среду передачи данных, а необходимо использовать другую, применяются трансиверы и конверторы.\r\n\r\nТрансивер (приемопередатчик, transmitter+receiver) – это часть сетевого адаптера, его оконечное устройство, выходящее на кабель. В первом стандарте Ethernet, работающем на толстом коаксиале, трансивер располагался непосредственно на кабеле и связывался с остальной частью адаптера, располагавшейся внутри компьютера, с помощью интерфейса AUI (attachment unit interface). В других вариантах Ethernet\'а оказалось удобным выпускать сетевые адаптеры (да и другие коммуникационные устройства) с портом AUI, к которому можно присоединить трансивер для требуемой среды.\r\n<br>\r\nВместо подбора подходящего трансивера можно использовать конвертор, который может согласовать выход приемопередатчика, предназначенного для одной среды, с другой средой передачи данных (например, выход на витую пару преобразуется в выход на коаксиальный кабель).\r\n\r\n', 3, 1609332140, 8);

-- --------------------------------------------------------

--
-- Структура таблицы `articles_cat`
--

CREATE TABLE `articles_cat` (
  `id` int(11) UNSIGNED NOT NULL,
  `title` varchar(100) CHARACTER SET utf8 NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;

--
-- Дамп данных таблицы `articles_cat`
--

INSERT INTO `articles_cat` (`id`, `title`) VALUES
(1, 'Fence'),
(2, 'Stone'),
(3, 'It_Технологии'),
(4, 'Виджеты'),
(5, 'Python');

-- --------------------------------------------------------

--
-- Структура таблицы `sing_up`
--

CREATE TABLE `sing_up` (
  `id` int(11) UNSIGNED NOT NULL,
  `name` varchar(25) NOT NULL,
  `login` varchar(111) NOT NULL,
  `password` varchar(111) NOT NULL,
  `reg_date` int(11) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `sing_up`
--

INSERT INTO `sing_up` (`id`, `name`, `login`, `password`, `reg_date`) VALUES
(1, 'Danil', 'admin', '0192023a7bbd73250516f069df18b500', 1599075854),
(2, 'dim', 'dim@.ru', 'd8578edf8458ce06fbc5bb76a58c5ca4', 1600367188),
(3, 'Аркадша Данил Лексеевич', 'admin@dasd.us', '7c6920301ed6bcbad9b77584b705e3b3', 1671292855);

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `articles`
--
ALTER TABLE `articles`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `title` (`title`);

--
-- Индексы таблицы `articles_cat`
--
ALTER TABLE `articles_cat`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `title` (`title`);

--
-- Индексы таблицы `sing_up`
--
ALTER TABLE `sing_up`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `login` (`login`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `articles`
--
ALTER TABLE `articles`
  MODIFY `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- AUTO_INCREMENT для таблицы `articles_cat`
--
ALTER TABLE `articles_cat`
  MODIFY `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;

--
-- AUTO_INCREMENT для таблицы `sing_up`
--
ALTER TABLE `sing_up`
  MODIFY `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
